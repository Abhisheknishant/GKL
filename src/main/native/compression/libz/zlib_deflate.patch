--- ../otc_zlib/deflate.c	2017-03-22 11:09:41.437641989 -0400
+++ deflate_new.c	2017-03-21 11:29:53.169060805 -0400
@@ -51,12 +51,20 @@
 
 #include "deflate.h"
 
+#define USE_IGZIP
+
 #if defined(CHECK_SSE2) || defined(USE_SSE4_2_CRC_HASH) || defined(USE_QUICK)
 #include "x86.h"
 #endif
 
+
+#ifdef USE_IGZIP
+#include "igzip_lib.h"
+#endif
+
+
 const char deflate_copyright[] =
-   " deflate 1.2.8.1 Copyright 1995-2013 Jean-loup Gailly and Mark Adler ";
+   " deflate 1.2.8 Copyright 1995-2013 Jean-loup Gailly and Mark Adler ";
 /*
   If you use the zlib library in a product, an acknowledgment is welcome
   in the documentation of your product. If for some reason you cannot
@@ -71,7 +79,6 @@
 typedef block_state (*compress_func) OF((deflate_state *s, int flush));
 /* Compression function. Returns the block state after the call. */
 
-local int deflateStateCheck      OF((z_streamp strm));
 local void fill_window    OF((deflate_state *s));
 local block_state deflate_stored OF((deflate_state *s, int flush));
 local block_state deflate_fast   OF((deflate_state *s, int flush));
@@ -85,15 +92,15 @@
 local void lm_init        OF((deflate_state *s));
 local void putShortMSB    OF((deflate_state *s, uInt b));
 ZLIB_INTERNAL void flush_pending  OF((z_streamp strm));
-ZLIB_INTERNAL unsigned read_buf   OF((z_streamp strm, Bytef *buf, unsigned size));
+ZLIB_INTERNAL int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
 #ifdef ASMV
       void match_init OF((void)); /* asm code initialization */
       uInt longest_match  OF((deflate_state *s, IPos cur_match));
 #else
-# include "match.c"
+local uInt longest_match  OF((deflate_state *s, IPos cur_match));
 #endif
 
-#ifdef ZLIB_DEBUG
+#ifdef DEBUG
 local  void check_match OF((deflate_state *s, IPos start, IPos match,
                             int length));
 #endif
@@ -166,8 +173,15 @@
  * meaning.
  */
 
+#define EQUAL 0
+/* result of memcmp for equal strings */
+
+#ifndef NO_DUMMY_DECL
+struct static_tree_desc_s {int dummy;}; /* for buggy compilers */
+#endif
+
 /* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */
-#define RANK(f) (((f) * 2) - ((f) > 4 ? 9 : 0))
+#define RANK(f) (((f) << 1) - ((f) > 4 ? 9 : 0))
 
 
 /* ===========================================================================
@@ -249,8 +263,9 @@
     const char *version;
     int stream_size;
 {
-    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
+     return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
                          Z_DEFAULT_STRATEGY, version, stream_size);
+
     /* To do: ignore strm->next_in if we use it as window */
 }
 
@@ -320,24 +335,24 @@
 #endif
     if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
         windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
-        strategy < 0 || strategy > Z_FIXED || (windowBits == 8 && wrap != 1)) {
+        strategy < 0 || strategy > Z_FIXED) {
         return Z_STREAM_ERROR;
     }
     if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
 
 #ifdef USE_QUICK
-    if (level == 1 && windowBits > 13)
+    if (level == 1)
         windowBits = 13;
 #endif
+
     s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
     if (s == Z_NULL) return Z_MEM_ERROR;
     strm->state = (struct internal_state FAR *)s;
     s->strm = strm;
-    s->status = INIT_STATE;     /* to pass state test in deflateReset() */
 
     s->wrap = wrap;
     s->gzhead = Z_NULL;
-    s->w_bits = (uInt)windowBits;
+    s->w_bits = windowBits;
     s->w_size = 1 << s->w_bits;
     s->w_mask = s->w_size - 1;
 
@@ -346,7 +361,7 @@
         s->hash_bits = 15;
     else
 #endif
-    s->hash_bits = (uInt)memLevel + 7;
+    s->hash_bits = memLevel + 7;
 
     s->hash_size = 1 << s->hash_bits;
     s->hash_mask = s->hash_size - 1;
@@ -382,29 +397,29 @@
     s->strategy = strategy;
     s->method = (Byte)method;
 
-    return deflateReset(strm);
-}
+    int ret =  deflateReset(strm);
+    #ifdef USE_IGZIP
+        if(level ==1){
+            if(windowBits<0)
+	        {
+                strm->state->strm = (z_streamp) ZALLOC(strm, 1, sizeof(struct isal_zstream));
+                isal_deflate_init((struct isal_zstream*)strm->state->strm);
+                ((struct isal_zstream*)strm->state->strm)->end_of_stream = 0;
+                ((struct isal_zstream*)strm->state->strm)->hufftables = 0x0;
+                ((struct isal_zstream*)strm->state->strm)->gzip_flag = 0;
+            }
+            else
+            {
+                 strm->state->strm = (z_streamp) ZALLOC(strm, 1, sizeof(struct isal_zstream));
+                 isal_deflate_init((struct isal_zstream*)strm->state->strm);
+                 ((struct isal_zstream*)strm->state->strm)->end_of_stream = 0;
+                 ((struct isal_zstream*)strm->state->strm)->hufftables = 0x0;
+                 ((struct isal_zstream*)strm->state->strm)->gzip_flag = 1;
+            }
+        }
 
-/* =========================================================================
- * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
- */
-local int deflateStateCheck (strm)
-    z_streamp strm;
-{
-    deflate_state *s;
-    if (strm == Z_NULL ||
-        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)
-        return 1;
-    s = strm->state;
-    if (s == Z_NULL || s->strm != strm || (s->status != INIT_STATE &&
-                                           s->status != EXTRA_STATE &&
-                                           s->status != NAME_STATE &&
-                                           s->status != COMMENT_STATE &&
-                                           s->status != HCRC_STATE &&
-                                           s->status != BUSY_STATE &&
-                                           s->status != FINISH_STATE))
-        return 1;
-    return 0;
+    #endif
+    return ret;
 }
 
 /* ========================================================================= */
@@ -419,7 +434,7 @@
     unsigned avail;
     z_const unsigned char *next;
 
-    if (deflateStateCheck(strm) || dictionary == Z_NULL)
+    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL)
         return Z_STREAM_ERROR;
     s = strm->state;
     wrap = s->wrap;
@@ -482,7 +497,8 @@
 {
     deflate_state *s;
 
-    if (deflateStateCheck(strm)) {
+    if (strm == Z_NULL || strm->state == Z_NULL ||
+        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {
         return Z_STREAM_ERROR;
     }
 
@@ -527,8 +543,8 @@
     z_streamp strm;
     gz_headerp head;
 {
-    if (deflateStateCheck(strm) || strm->state->wrap != 2)
-        return Z_STREAM_ERROR;
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    if (strm->state->wrap != 2) return Z_STREAM_ERROR;
     strm->state->gzhead = head;
     return Z_OK;
 }
@@ -539,7 +555,7 @@
     int *bits;
     z_streamp strm;
 {
-    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
     if (pending != Z_NULL)
         *pending = strm->state->pending;
     if (bits != Z_NULL)
@@ -556,7 +572,7 @@
     deflate_state *s;
     int put;
 
-    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
     s = strm->state;
     if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))
         return Z_BUF_ERROR;
@@ -583,7 +599,7 @@
     compress_func func;
     int err = Z_OK;
 
-    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
     s = strm->state;
 
 #ifdef FASTEST
@@ -596,7 +612,8 @@
     }
     func = configuration_table[s->level].func;
 
-    if ((strategy != s->strategy || func != configuration_table[level].func)) {
+    if ((strategy != s->strategy || func != configuration_table[level].func) &&
+        strm->total_in != 0) {
         /* Flush the last buffer: */
         err = deflate(strm, Z_BLOCK);
         if (err == Z_BUF_ERROR && s->pending == 0)
@@ -623,12 +640,12 @@
 {
     deflate_state *s;
 
-    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
     s = strm->state;
-    s->good_match = (uInt)good_length;
-    s->max_lazy_match = (uInt)max_lazy;
+    s->good_match = good_length;
+    s->max_lazy_match = max_lazy;
     s->nice_match = nice_length;
-    s->max_chain_length = (uInt)max_chain;
+    s->max_chain_length = max_chain;
     return Z_OK;
 }
 
@@ -662,7 +679,7 @@
               ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;
 
     /* if can't get parameters, return conservative bound plus zlib wrapper */
-    if (deflateStateCheck(strm))
+    if (strm == Z_NULL || strm->state == Z_NULL)
         return complen + 6;
 
     /* compute wrapper length */
@@ -755,13 +772,84 @@
     int old_flush; /* value of flush param for previous deflate call */
     deflate_state *s;
 
-    if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
+#ifdef USE_IGZIP
+     s = strm->state;
+
+    if( (s->level == 1) && (s->w_bits<=0 || (s->w_bits<31 && s->w_bits>24))){
+
+    int original_flush = flush;
+
+    if(flush == Z_FINISH || flush == Z_FULL_FLUSH) {
+    flush = FULL_FLUSH;
+    }
+    else if(flush == Z_SYNC_FLUSH ) {
+    flush = SYNC_FLUSH;
+    }
+    else if(flush != Z_NO_FLUSH ){
+    ERR_RETURN(strm, Z_STREAM_ERROR);
+    }
+
+
+    if(s->w_bits<=0)
+      {
+      ((struct isal_zstream *)s->strm)->gzip_flag = 0;
+      }
+      else if(s->w_bits<31 && s->w_bits>24){
+      ((struct isal_zstream *)s->strm)->gzip_flag = 1;
+      }
+
+
+    if(((struct isal_zstream*)s->strm)->hufftables == 0x0)
+              {
+                struct isal_huff_histogram histogram;
+                struct isal_hufftables *hufftables_custom;
+                int sixtyfourK = 64*1024;
+                int usable_buffer= (strm->avail_in < sixtyfourK) ? strm->avail_in : sixtyfourK;
+
+                 hufftables_custom = (struct isal_hufftables*) malloc(sizeof(struct isal_hufftables));
+
+                 memset(&histogram, 0, sizeof(histogram));
+                 isal_update_histogram((unsigned char*)strm->next_in,usable_buffer, &histogram);
+                 isal_create_hufftables(hufftables_custom, &histogram);
+                 ((struct isal_zstream*)s->strm)->hufftables = hufftables_custom;
+         }
+
+
+        ((struct isal_zstream *)s->strm)->next_in = strm->next_in;
+        ((struct isal_zstream *)s->strm)->avail_in = strm->avail_in;
+        ((struct isal_zstream *)s->strm)->avail_out = strm->avail_out;
+        ((struct isal_zstream *)s->strm)->next_out = strm->next_out;
+        ((struct isal_zstream *)s->strm)->flush = flush;
+        ((struct isal_zstream *)s->strm)->end_of_stream = 1;
+
+        //printf("Next_in =  %p, Next_out = %p, Avail_in = %d, Avail_out = %d\n",strm->next_in, strm->next_out, strm->avail_in, strm->avail_out);
+
+         int ret = isal_deflate_stateless((struct isal_zstream*)s->strm);
+
+         printf("Using igzip\n");
+         strm->avail_in = ((struct isal_zstream *)s->strm)->avail_in;
+         strm->next_in = ((struct isal_zstream *)s->strm)->next_in;
+         strm->avail_out = ((struct isal_zstream *)s->strm)->avail_out;
+         strm->next_out = ((struct isal_zstream *)s->strm)->next_out;
+         strm->total_out =((struct isal_zstream *)s->strm)->total_out;
+         strm->total_in =((struct isal_zstream *)s->strm)->total_in;
+         if(original_flush == Z_FINISH && ret == COMP_OK) ret = Z_STREAM_END;
+
+        return ret;
+
+
+     }
+
+#endif
+
+    if (strm == Z_NULL || strm->state == Z_NULL ||
+        flush > Z_BLOCK || flush < 0) {
         return Z_STREAM_ERROR;
     }
     s = strm->state;
 
     if (strm->next_out == Z_NULL ||
-        (strm->avail_in != 0 && strm->next_in == Z_NULL) ||
+        (strm->next_in == Z_NULL && strm->avail_in != 0) ||
         (s->status == FINISH_STATE && flush != Z_FINISH)) {
         ERR_RETURN(strm, Z_STREAM_ERROR);
     }
@@ -771,6 +859,8 @@
     old_flush = s->last_flush;
     s->last_flush = flush;
 
+  // printf("Next_in =  %p, Next_out = %p, Avail_in = %d, Avail_out = %d\n",strm->next_in, strm->next_out, strm->avail_in, strm->avail_out);
+
     /* Write the header */
     if (s->status == INIT_STATE) {
 #ifdef GZIP
@@ -962,6 +1052,7 @@
              * return OK instead of BUF_ERROR at next call of deflate:
              */
             s->last_flush = -1;
+
             return Z_OK;
         }
 
@@ -985,18 +1076,16 @@
         (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
         block_state bstate;
 
-
-        if (s->level == 0)
-            bstate = deflate_stored(s, flush);
-        else if (s->strategy == Z_HUFFMAN_ONLY)
-            bstate = deflate_huff(s, flush);
-        else if (s->strategy == Z_RLE)
-            bstate = deflate_rle(s, flush);
-        else if (s->level == 1 && !x86_cpu_has_sse42)
-            bstate = deflate_fast(s, flush);
+#ifdef USE_QUICK
+        if (s->level == 1 && !x86_cpu_has_sse42) 
+            bstate = s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
+                    (s->strategy == Z_RLE ? deflate_rle(s, flush) :
+                        deflate_fast(s, flush));
         else
-            bstate = (*(configuration_table[s->level].func))(s, flush);
-
+#endif
+            bstate = s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
+                    (s->strategy == Z_RLE ? deflate_rle(s, flush) :
+                        (*(configuration_table[s->level].func))(s, flush));
 
         if (bstate == finish_started || bstate == finish_done) {
             s->status = FINISH_STATE;
@@ -1005,6 +1094,7 @@
             if (strm->avail_out == 0) {
                 s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
             }
+
             return Z_OK;
             /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
              * of deflate should use the same flush parameter to make sure
@@ -1034,12 +1124,15 @@
             flush_pending(strm);
             if (strm->avail_out == 0) {
               s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
+
               return Z_OK;
             }
         }
     }
     Assert(strm->avail_out > 0, "bug2");
 
+
+
     if (flush != Z_FINISH) return Z_OK;
     if (s->wrap <= 0) return Z_STREAM_END;
 
@@ -1062,10 +1155,13 @@
         putShortMSB(s, (uInt)(strm->adler >> 16));
         putShortMSB(s, (uInt)(strm->adler & 0xffff));
     }
+
+
     flush_pending(strm);
     /* If avail_out is zero, the application will call deflate again
      * to flush the rest.
      */
+
     if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */
     return s->pending != 0 ? Z_OK : Z_STREAM_END;
 }
@@ -1076,9 +1172,33 @@
 {
     int status;
 
-    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
+#ifdef USE_IGZIP
+    if(strm->state->level ==1 && (strm->state->w_bits<0))
+    {
+      /* Deallocate in reverse order of allocations: */
+      TRY_FREE(strm, strm->state->pending_buf);
+      TRY_FREE(strm, strm->state->head);
+      TRY_FREE(strm, strm->state->prev);
+      TRY_FREE(strm, strm->state->window);
+      ZFREE(strm, strm->state->strm);
+      ZFREE(strm, strm->state);
+      strm->state = Z_NULL;
+      return Z_OK;
+    }
+#endif
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
 
     status = strm->state->status;
+    if (status != INIT_STATE &&
+        status != EXTRA_STATE &&
+        status != NAME_STATE &&
+        status != COMMENT_STATE &&
+        status != HCRC_STATE &&
+        status != BUSY_STATE &&
+        status != FINISH_STATE) {
+      return Z_STREAM_ERROR;
+    }
 
     /* Deallocate in reverse order of allocations: */
     TRY_FREE(strm, strm->state->pending_buf);
@@ -1109,7 +1229,7 @@
     ushf *overlay;
 
 
-    if (deflateStateCheck(source) || dest == Z_NULL) {
+    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
         return Z_STREAM_ERROR;
     }
 
@@ -1159,7 +1279,7 @@
  * allocating a large strm->next_in buffer and copying from it.
  * (See also flush_pending()).
  */
-ZLIB_INTERNAL unsigned read_buf(strm, buf, size)
+ZLIB_INTERNAL int read_buf(strm, buf, size)
     z_streamp strm;
     Bytef *buf;
     unsigned size;
@@ -1184,7 +1304,7 @@
     strm->next_in  += len;
     strm->total_in += len;
 
-    return len;
+    return (int)len;
 }
 
 /* ===========================================================================
@@ -1218,12 +1338,9 @@
 #endif
 }
 
+#include "match.c"
 
-#ifdef ZLIB_DEBUG
-
-#define EQUAL 0
-/* result of memcmp for equal strings */
-
+#ifdef DEBUG
 /* ===========================================================================
  * Check that the match at match_start is indeed a match.
  */
@@ -1249,7 +1366,7 @@
 }
 #else
 #  define check_match(s, start, match, length)
-#endif /* ZLIB_DEBUG */
+#endif /* DEBUG */
 
 /* ===========================================================================
  * Fill the window when the lookahead becomes insufficient.
@@ -1492,7 +1609,7 @@
         s->lookahead = 0;
 
         /* Emit a stored block if pending_buf will be full: */
-        max_start = max_block_size + (ulg)s->block_start;
+        max_start = s->block_start + max_block_size;
         if (s->strstart == 0 || (ulg)s->strstart >= max_start) {
             /* strstart == 0 is possible when wraparound on 16-bit machine */
             s->lookahead = (uInt)(s->strstart - max_start);
@@ -1795,7 +1912,7 @@
                          prev == *++scan && prev == *++scan &&
                          prev == *++scan && prev == *++scan &&
                          scan < strend);
-                s->match_length = MAX_MATCH - (uInt)(strend - scan);
+                s->match_length = MAX_MATCH - (int)(strend - scan);
                 if (s->match_length > s->lookahead)
                     s->match_length = s->lookahead;
             }
